{
    "table_definition": {
        "$ref": "${table_definition_dir}/supremm/supremmfact_by.json#/table_definition"
    },
    "aggregation_period_query": {
        "overseer_restrictions": {
            "last_modified_start_date": "last_modified >= ${VALUE}",
            "last_modified_end_date": "last_modified <= ${VALUE}",
            "include_only_resource_codes": "resource_id IN ${VALUE}",
            "exclude_resource_codes": "resource_id NOT IN ${VALUE}"
        },
        "conversions": {
            "start_day_id": "YEAR(FROM_UNIXTIME(start_time_ts)) * 100000 + DAYOFYEAR(FROM_UNIXTIME(start_time_ts))",
            "end_day_id": "YEAR(FROM_UNIXTIME(end_time_ts)) * 100000 + DAYOFYEAR(FROM_UNIXTIME(end_time_ts))"
        }
    },
    "destination_query": {
        "overseer_restrictions": {
            "include_only_resource_codes": "record_resource_id IN ${VALUE}",
            "exclude_resource_codes": "record_resource_id NOT IN ${VALUE}"
        }
    },
    "source_query": {
        "overseer_restrictions": {
            "include_only_resource_codes": "record.resource_id IN ${VALUE}",
            "exclude_resource_codes": "record.resource_id NOT IN ${VALUE}"
        },
        "query_hint": "SQL_NO_CACHE",
        "records": {
            "${AGGREGATION_UNIT}_id": "${:PERIOD_ID}",
            "year": "${:YEAR_VALUE}",
            "${AGGREGATION_UNIT}": "${:PERIOD_VALUE}",
            "application_id": "application_id",
            "block_sda_rd_bytes": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_rd_bytes * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_rd_bytes * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (block_sda_rd_bytes * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (block_sda_rd_bytes * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (block_sda_rd_bytes * nodecount_id)  end)",
            "block_sda_rd_bytes_weight": "sum( case when ( block_sda_rd_bytes IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "block_sda_rd_ios": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_rd_ios * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_rd_ios * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (block_sda_rd_ios * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (block_sda_rd_ios * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (block_sda_rd_ios * nodecount_id)  end)",
            "block_sda_rd_ios_weight": "sum( case when ( block_sda_rd_ios IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "block_sda_wr_bytes": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_wr_bytes * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_wr_bytes * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (block_sda_wr_bytes * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (block_sda_wr_bytes * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (block_sda_wr_bytes * nodecount_id)  end)",
            "block_sda_wr_bytes_weight": "sum( case when ( block_sda_wr_bytes IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "block_sda_wr_ios": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_wr_ios * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (block_sda_wr_ios * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (block_sda_wr_ios * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (block_sda_wr_ios * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (block_sda_wr_ios * nodecount_id)  end)",
            "block_sda_wr_ios_weight": "sum( case when ( block_sda_wr_ios IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "catastrophe_bucket_id": "(SELECT id FROM modw_supremm.catastrophe_buckets cb WHERE coalesce(catastrophe, -1.0) > cb.min AND coalesce(catastrophe, -1.0) <= cb.max)",
            "cores": "cores",
            "cpibucket_id": "(SELECT id FROM modw_supremm.cpibuckets cb WHERE coalesce(cpiref, -1.0) > cb.min_cpi AND coalesce(cpiref, -1.0) <= cb.max_cpi)",
            "cpiref_weight": "sum( case when (cpiref IS NOT NULL) then 1.0 else 0.0 end * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "cpiref_weighted_by_coreseconds": "sum(cpiref * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "cpldref_weight": "sum( case when (cpldref IS NOT NULL) then 1.0 else 0.0 end * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "cpldref_weighted_by_coreseconds": "sum(cpldref * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "cpu_time": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (cpu_time) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (cpu_time) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (cpu_time)  end)",
            "cpu_time_idle": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time*cpu_idle)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time*cpu_idle) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (cpu_time*cpu_idle) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (cpu_time*cpu_idle) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (cpu_time*cpu_idle)  end)",
            "cpu_time_system": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time*cpu_system)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time*cpu_system) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (cpu_time*cpu_system) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (cpu_time*cpu_system) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (cpu_time*cpu_system)  end)",
            "cpu_time_user": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time*cpu_user)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (cpu_time*cpu_user) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (cpu_time*cpu_user) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (cpu_time*cpu_user) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (cpu_time*cpu_user)  end)",
            "cpu_usage_weight": "sum( case when (cpu_user IS NOT NULL) then 1.0 else 0.0 end * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "cpu_user_bucketid": "(SELECT id FROM modw_supremm.percentages_buckets cb WHERE coalesce(100.0 * cpu_user, -1.0) > cb.min AND coalesce(100.0 * cpu_user, -1.0) <= cb.max)",
            "cpu_user_cv_id": "(SELECT id FROM modw_supremm.cpu_user_cv_buckets cb WHERE coalesce(cpu_user_cv, -1.0) > cb.min AND coalesce(cpu_user_cv, -1.0) <= cb.max)",
            "cpu_user_cv_weighted_core_seconds": "sum(cpu_user_cv * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "cpu_user_imbalance_weighted_core_seconds": "sum(cpu_user_imbalance * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "datasource_id": "datasource_id",
            "exit_status_id": "exit_status_id",
            "flop": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (flops)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (flops) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (flops) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (flops) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (flops)  end)",
            "flop_weight": "sum( case when (flops IS NOT NULL) then 1.0 else 0.0 end * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "fos_id": "fos_id",
            "gpu0_nv_utilization": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (gpu0_nv_utilization*node_time)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (gpu0_nv_utilization*node_time) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (gpu0_nv_utilization*node_time) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (gpu0_nv_utilization*node_time) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (gpu0_nv_utilization*node_time)  end)",
            "gpu0_nv_utilization_bucketid": "(SELECT id FROM modw_supremm.percentages_buckets cb WHERE coalesce(100.0 * gpu0_nv_utilization, -1.0) > cb.min AND coalesce(100.0 * gpu0_nv_utilization, -1.0) <= cb.max)",
            "gpu0_nv_utilization_weight": "sum( case when (gpu0_nv_utilization IS NOT NULL) then 1.0 else 0.0 end * nodes * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "granted_pe": "granted_pe",
            "ib_rx_bytes": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (ib_rx_bytes * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (ib_rx_bytes * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (ib_rx_bytes * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (ib_rx_bytes * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (ib_rx_bytes * nodecount_id)  end)",
            "ib_rx_bytes_weight": "sum( case when ( ib_rx_bytes IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "ibrxbyterate_bucket_id": "(SELECT id FROM modw_supremm.logscalebytes_buckets cb WHERE coalesce(ib_rx_bytes/wall_time, -1.0) > cb.min AND coalesce(ib_rx_bytes/wall_time, -1.0) <= cb.max)",
            "job_count": "sum(CASE WHEN end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} then 1 else 0 end)",
            "jobtime_id": "(select id from job_times jt where wall_time >= jt.min_duration and wall_time <= jt.max_duration)",
            "max_mem_bucketid": "(SELECT id FROM modw_supremm.percentages_buckets cb WHERE coalesce(100.0 * max_memory, -1.0) > cb.min AND coalesce(100.0 * max_memory, -1.0) <= cb.max)",
            "mem_transferred": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (mem_transferred)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (mem_transferred) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (mem_transferred) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (mem_transferred) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (mem_transferred)  end)",
            "mem_transferred_weight": "sum( case when (mem_transferred IS NOT NULL) then 1.0 else 0.0 end * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "mem_usage_weight": "sum( case when (memory_used IS NOT NULL) then 1.0 else 0.0 end * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "mem_used_including_os_caches_weighted_by_duration": "sum(mem_used_including_os_caches * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "mem_used_weighted_by_duration": "sum(memory_used * cores * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "net_eth0_rx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_eth0_rx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_eth0_rx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (net_eth0_rx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (net_eth0_rx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (net_eth0_rx * nodecount_id)  end)",
            "net_eth0_rx_weight": "sum( case when ( net_eth0_rx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "net_eth0_tx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_eth0_tx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_eth0_tx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (net_eth0_tx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (net_eth0_tx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (net_eth0_tx * nodecount_id)  end)",
            "net_eth0_tx_weight": "sum( case when ( net_eth0_tx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "net_ib0_rx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_ib0_rx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_ib0_rx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (net_ib0_rx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (net_ib0_rx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (net_ib0_rx * nodecount_id)  end)",
            "net_ib0_rx_weight": "sum( case when ( net_ib0_rx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "net_ib0_tx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_ib0_tx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (net_ib0_tx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (net_ib0_tx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (net_ib0_tx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (net_ib0_tx * nodecount_id)  end)",
            "net_ib0_tx_weight": "sum( case when ( net_ib0_tx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "netdrv_gpfs_rx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_gpfs_rx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_gpfs_rx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (netdrv_gpfs_rx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (netdrv_gpfs_rx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (netdrv_gpfs_rx * nodecount_id)  end)",
            "netdrv_gpfs_rx_bucket_id": "(SELECT id FROM modw_supremm.log2scale_buckets cb WHERE coalesce(netdrv_gpfs_rx*nodes, -1.0) > cb.min AND coalesce(netdrv_gpfs_rx*nodes, -1.0) <= cb.max)",
            "netdrv_gpfs_rx_weight": "sum( case when ( netdrv_gpfs_rx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "netdrv_gpfs_tx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_gpfs_tx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_gpfs_tx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (netdrv_gpfs_tx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (netdrv_gpfs_tx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (netdrv_gpfs_tx * nodecount_id)  end)",
            "netdrv_gpfs_tx_weight": "sum( case when ( netdrv_gpfs_tx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "netdrv_isilon_rx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_isilon_rx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_isilon_rx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (netdrv_isilon_rx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (netdrv_isilon_rx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (netdrv_isilon_rx * nodecount_id)  end)",
            "netdrv_isilon_rx_bucket_id": "(SELECT id FROM modw_supremm.log2scale_buckets cb WHERE coalesce(netdrv_isilon_rx*nodes, -1.0) > cb.min AND coalesce(netdrv_isilon_rx*nodes, -1.0) <= cb.max)",
            "netdrv_isilon_rx_weight": "sum( case when ( netdrv_isilon_rx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "netdrv_isilon_tx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_isilon_tx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_isilon_tx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (netdrv_isilon_tx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (netdrv_isilon_tx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (netdrv_isilon_tx * nodecount_id)  end)",
            "netdrv_isilon_tx_weight": "sum( case when ( netdrv_isilon_tx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "netdrv_panasas_rx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_panasas_rx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_panasas_rx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (netdrv_panasas_rx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (netdrv_panasas_rx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (netdrv_panasas_rx * nodecount_id)  end)",
            "netdrv_panasas_rx_bucket_id": "(SELECT id FROM modw_supremm.log2scale_buckets cb WHERE coalesce(netdrv_panasas_rx*nodes, -1.0) > cb.min AND coalesce(netdrv_panasas_rx*nodes, -1.0) <= cb.max)",
            "netdrv_panasas_rx_weight": "sum( case when ( netdrv_panasas_rx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "netdrv_panasas_tx": "sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_panasas_tx * nodecount_id)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then (netdrv_panasas_tx * nodecount_id) * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then (netdrv_panasas_tx * nodecount_id) * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    (netdrv_panasas_tx * nodecount_id) *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else (netdrv_panasas_tx * nodecount_id)  end)",
            "netdrv_panasas_tx_weight": "sum( case when ( netdrv_panasas_tx IS NOT NULL) then 1.0 else 0.0 end * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "node_time": "coalesce(sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then node_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then node_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then node_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    node_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else node_time  end), 0)",
            "nodecount_id": "nodecount_id",
            "organization_id": "organization_id",
            "person_id": "person_id",
            "person_organization_id": "person_organization_id",
            "piperson_organization_id": "piperson_organization_id",
            "principalinvestigator_person_id": "principalinvestigator_person_id",
            "processorbucket_id": "(select id from processor_buckets pb where cores between pb.min_processors and pb.max_processors)",
            "queue_id": "queue_id",
            "requested_wall_time": "coalesce(sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then requested_wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then requested_wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then requested_wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    requested_wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else requested_wall_time  end),0)",
            "resource_id": "resource_id",
            "running_job_count": "sum(1)",
            "shared": "shared",
            "started_job_count": "sum(CASE WHEN start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} then 1 else 0 end)",
            "submitted_job_count": "sum(CASE WHEN submit_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} then 1 else 0 end)",
            "sum_weighted_expansion_factor": "sum( ((wall_time + wait_time) / wall_time) * nodecount_id * case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end)",
            "systemaccount_id": "systemaccount_id",
            "wait_time": "coalesce(sum(CASE WHEN start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} then wait_time else 0 end),0)",
            "wall_time": "coalesce(sum(case when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} )  then wall_time * (end_time_ts - ${:PERIOD_START_TS} + 1 ) / ( end_time_ts - start_time_ts + 1)  when (start_time_ts between ${:PERIOD_START_TS} and ${:PERIOD_END_TS} and end_time_ts > ${:PERIOD_END_TS} )  then wall_time * (${:PERIOD_END_TS} - start_time_ts + 1 ) / (end_time_ts - start_time_ts + 1)  when (start_time_ts < ${:PERIOD_START_TS} and end_time_ts > ${:PERIOD_END_TS} )  then    wall_time *( ${:PERIOD_SECONDS} ) / (end_time_ts - start_time_ts + 1)  else wall_time  end),0)"
        },
        "groupby": [
            "application_id",
            "catastrophe_bucket_id",
            "cores",
            "cpibucket_id",
            "cpu_user_bucketid",
            "cpu_user_cv_id",
            "datasource_id",
            "exit_status_id",
            "fos_id",
            "gpu0_nv_utilization_bucketid",
            "granted_pe",
            "ibrxbyterate_bucket_id",
            "jobtime_id",
            "max_mem_bucketid",
            "netdrv_gpfs_rx_bucket_id",
            "netdrv_isilon_rx_bucket_id",
            "netdrv_panasas_rx_bucket_id",
            "nodecount_id",
            "organization_id",
            "person_id",
            "person_organization_id",
            "piperson_organization_id",
            "principalinvestigator_person_id",
            "queue_id",
            "resource_id",
            "shared",
            "systemaccount_id"
        ],
        "joins": [
            {
                "name": "job",
                "schema": "${SOURCE_SCHEMA}",
                "alias": "jf"
            }
        ],
        "where": [
            "YEAR(FROM_UNIXTIME(jf.start_time_ts)) * 100000 + DAYOFYEAR(FROM_UNIXTIME(jf.start_time_ts)) <= ${:PERIOD_END_DAY_ID} AND YEAR(FROM_UNIXTIME(jf.end_time_ts)) * 100000 + DAYOFYEAR(FROM_UNIXTIME(jf.end_time_ts)) >= ${:PERIOD_START_DAY_ID}"
        ]
    }
}